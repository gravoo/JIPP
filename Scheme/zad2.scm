; (load "zad2.scm")
; (deriv '((x * x) + ((y * x) + z))  'x)
; (deriv '(x / b) 'x) 
; (deriv '(x * b) 'x) 
; (deriv '((x + a) * (x + b)) 'x)
(define (deriv exp var)
  (cond
    ((or (symbol? exp)(number? exp)) exp)
    ((operation exp '+)
     (make-sum (deriv (car exp) var)
                          (deriv (caddr exp) var)))
    ((operation exp '-)
        (make-sub (deriv (car exp) var) (deriv (caddr exp) var)))
    ((operation exp '*)
        (make-product (deriv (car exp) var) (deriv (caddr exp) var)))
    ((operation exp '/)
        (make-div (deriv (car exp) var) (deriv (caddr exp) var)))
    ))

(define (operation exp operand)
  (and (pair? exp) (eqv? operand (cadr exp))))
(define (make-sum a b)
  (cond ((and(number? a)(number? b) (+ a b)))
        (else (list a '+ b))))
(define (make-product a b)
  (cond ((and(number? a)(number? b) (* a b)))
        (else (list a '* b))))
(define (make-sub a b)
  (cond ((and(number? a)(number? b) (- a b)))
        (else (list a '- b))))
(define (make-div a b)
  (cond ((and(number? a)(number? b) (/ a b)))
        (else (list a '/ b))))

(trace deriv)
(trace make-sum)
(trace sum?)

(define (pochodna wyrazenie)
  (cond
    ((null? wyrazenie) 0)
    ((symbol? wyrazenie) 'wyrazenie)
    ((null? (cdr wyrazenie)) (car wyrazenie))
    (else
      (let ((skladnik (car wyrazenie))
            (operator (cadr wyrazenie))
            (reszta (cddr wyrazenie)))
        ((case operator
           ((+) +))
        skladnik
        (pochodna reszta))
       ))
    ))
(trace pochodna)

